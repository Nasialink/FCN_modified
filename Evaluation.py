# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gu34cLf32yI-MZheiR6386rUU3-vjh8z
"""

import os
import tensorflow
import keras
import math
import matplotlib.pyplot as plt
import zipfile  # For faster extraction
import SimpleITK as sitk  # For loading the dataset
import numpy as np  # For data manipulation
import model
from model import loss_gt
import group_norm
import glob  # For populating the list of files
from scipy.ndimage import zoom  # For resizing
import re  # For parsing the filenames (to know their modality)
#import example_on_brats2018 #import resize #,read_img, preprocess, preprocess_label
from functions import *
import nibabel as nib
import json
from scipy.spatial.distance import directed_hausdorff

physical_devices = tensorflow.config.experimental.list_physical_devices('GPU') 
for device in physical_devices:
    tensorflow.config.experimental.set_memory_growth(device, True)

def predict_gt(model, input_data):
    # Set the VAE branch's output layer to None
    model.get_layer('Dec_VAE_Output').outbound_nodes = None

    # Predict using the modified model
    predictions = model.predict(input_data)

    # Return only the predictions from the GT branch
    gt_predictions = predictions[0]

    return gt_predictions



def dice_coefficient_per_label(y_true, y_pred):
    dice_scores = {}
    for label in [1, 2, 4]:  # Labels 1, 2, and 4
        y_true_label = (y_true == label).astype(np.float32)
        y_pred_label = (y_pred == label).astype(np.float32)
        intersection = np.sum(y_true_label * y_pred_label)
        dn = np.sum(y_true_label) + np.sum(y_pred_label)
        dice_scores[label] = 2 * intersection / (dn + 1e-8)
    return dice_scores

def hausdorff_distance_per_label(y_true, y_pred):
    hausdorff_distances = {}
    for label in [1, 2, 4]:  # Labels 1, 2, and 4
        y_true_label = np.array(y_true == label, dtype=np.int)
        y_pred_label = np.array(y_pred == label, dtype=np.int)
        y_true_points = np.argwhere(y_true_label)
        y_pred_points = np.argwhere(y_pred_label)
        hd1 = directed_hausdorff(y_true_points, y_pred_points)[0]
        hd2 = directed_hausdorff(y_pred_points, y_true_points)[0]
        hausdorff_distances[label] = max(hd1, hd2)
    return hausdorff_distances


'''
data_path = '/content/gdrive/MyDrive/Diplomatiki_new/brats/data.nii.gz'
labels_path = '/content/gdrive/MyDrive/Diplomatiki_new/brats/testset/labels_test_w_prepr.nii.gz'
path_checkpoint = '/content/gdrive/MyDrive/Diplomatiki_new/brats/training/cp.ckpt'
save_pred_path = '/content/gdrive/MyDrive/Diplomatiki_new/brats/predictions'
save_model_path = '/content/gdrive/MyDrive/Diplomatiki_new/brats/saved_model/mymodel.keras'
pred_path='/content/gdrive/MyDrive/Diplomatiki_new/brats/predictions/y_pred1.npy'
index_path= save_pred_path + '/test_ind.npy'
'''

data_path = '/media/nasia/ssd2tb/nasia/training_04292024_204255/testset/data_test.nii.gz'
labels_path = '/media/nasia/ssd2tb/nasia/training_04292024_204255/testset/labels_test.nii.gz'
save_pred_path = '/media/nasia/ssd2tb/nasia/training_04292024_204255/predictions'
save_model_path = '/media/nasia/ssd2tb/nasia/training_04292024_204255/saved_model/mymodel.keras'
#pred_path='/media/nasia/ssd2tb/nasia/training_04292024_204255/predictions/y_pred.npy'
#index_path= save_pred_path + '/test_ind.npy'
all_patient_metrics = {}

count =86

np_data = nib.load(data_path).get_fdata()
data= np_data[75:count,:,:,:,:]
np_labels = nib.load(labels_path).get_fdata()
labels= np_labels[75:count,:,:,:,:]
model_v = keras.models.load_model(save_model_path, compile=False)   # solution from https://stackoverflow.com/questions/48373845/loading-model-with-custom-loss-keras
print(np_data.shape, np_labels.shape)

y_pred= predict_gt(model_v, data)
print(type(y_pred), y_pred.shape)
np.save(os.path.join(save_pred_path, 'y_pred_86.npy'), y_pred)


# Loop over patients
for patient_id in range(y_pred.shape[0]):
    # Calculate metrics for the current patient
    dice_scores = dice_coefficient_per_label(labels[patient_id,:,:,:,:], y_pred[patient_id,:,:,:,:])
    hausdorff_distances = hausdorff_distance_per_label(labels[patient_id,:,:,:,:], y_pred[patient_id,:,:,:,:])
    
    # Store metrics in a dictionary for the current patient
    patient_metrics = {
        'dice_scores': dice_scores,
        'hausdorff_distances': hausdorff_distances
    }
    
    # Add patient metrics to the dictionary
    all_patient_metrics[f'Patient_{patient_id}'] = patient_metrics

# Save the dictionary to a JSON file
#json_file = "/content/gdrive/MyDrive/Diplomatiki_new/brats/predictions/all_patient_metrics.json"
json_file = save_pred_path+"75_86_patient_metrics.json"

with open(json_file, 'w') as f:
    json.dump(all_patient_metrics, f, indent=4)

print("Dice scores per label:", dice_scores)
print("Hausdorff distances per label:", hausdorff_distances)
